# 为什么要分布式

1. 可扩展性：将负载分到多台机器上
2. 稳定性：主机down了，从机可以顶上来
3. 解决延迟问题

# 复制

## 基于单个领导者的复制

### 基本流程

* 主机向从机发送binlog

### 同步复制和异步复制

同步复制会存在一直等待的情况，异步复制有可能会丢数据，比较好的是半同步，比如mongo的WriteConcren，一半节点写入就算写入成功

### 新增从库的流程

* 读取快照，全量复制
* 根据日志序列号更新复制期间主机的写入

### 节点宕机

1. 从机：追赶恢复，从日志中知道最后一次处理的事务，连接上主机后进行数据恢复

2. 主机：故障切换

   * 检测：超时，当从节点一段时间内接收不到主机的心跳，标记为主观下线，一般来说过半的节点认为主机下线，就会选取新的主机，redis有哨兵，mongo里有投票节点

   * 选择主库：

     > mongo
     >
     > * 较新的oplog
     > * 连接的从机多
     > * 优先级

   * 重新配置新的主库

### 故障切换存在问题

* 自增id的问题：down掉的主机的计时器可能会落后于新的主机，导致主键的重复
* 脑裂问题：两个节点都以为自己是主机

### 复制方式

#### 基于语句的复制

* 存在问题：随机函数会使主从不一致，有副作用的语句可能在不同的节点上有不同的作用

#### 基于WAL日志的复制

* 存在问题：过于底层，依赖操作系统，数据库版本不一致不能传输

#### 逻辑日志复制（基于行）

* 比如mysql的binlog，就是这种复制方式

#### 基于触发器的复制

* 代码层面

### 复制延时问题（关键词：最终一致性）

#### 读己之写

> 产生原因：用户的写入在主库，读取在从库，可能会产生刚写入读不到的情况
>
> 解决办法：
>
> * 客户端记录最近写入的时间，当时间太短时就在主库读

#### 单调读

* 在从库1中能读到，从库2中读不到
* 解决办法：保证用户在同一个从库读数据，比如将id hash

## 基于多个领导者的复制

### 优点

1. 性能
2. 允许某个数据中心全部宕机

### 缺点

1. 复杂
2. 自增id不能使用
3. 异地写入冲突

## 无主复制

### 读修复和反熵

### 仲裁写入，法定读取





